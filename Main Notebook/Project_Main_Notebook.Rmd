---
title: "Statistical Methods in Financial Engineering - Risk Management Project"
author: Chloe Morin-Leclerc, Felix-Antoine Groulx, Denis Genest, Thien Duy Tran
date: "`r format(Sys.time(), '%B %e, %Y')`"
output: html_notebook
---

<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
td {  /* Table  */
  font-size: 8px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

# Part I: Project Guidelines

## Context
You work as a quantitative analyst for a large investment bank. You and your team are responsible for
challenging the models used by traders and risk managers. You work with R and love reproducible research.
All your files are written in Rmarkdown or R notebook.

You can watch the introductory video on Rmarkdown to help you build properly the R file.
Moreover, you use GitHub with your team. Youâ€™ll build a dedicated project for the tasks below and use
RStudio with GitHub extensively. You also use Loom to share your findings with other teams in the investment
bank.

## Learning Objectives
1. Content (scientific rigor, concepts, creativity).\
2. Choose the right tools.\
3. Implement the steps correctly.\
4. Come up with innovative solutions.\

## Form: Coding, Collaboration and Presentation
1. Build RStudio project with proper folder structure and Rmarkdown/nootebook file to reproduce your results.\
2. Program with state-of-the-art coding standards.\
3. Use GitHub repository for collaborative research.\
4. Use Loom video for presenting your results.

## Objective
The objective of this project is to implement the risk management framework used for estimating the risk of a book of European call options by taking into account risk drivers such as the underlying asset and the implied volatility of the options.

# Part II: Data

## Loading the Data
The first step is to load the database 'Market'. 'Market' is a list of 5 elements: S&P500 index prices, VIX values, the term structure of interest rates, and traded call and put options information. To make sure this code can run on any platform, we use the library 'here'.

```{r}
# install.packages("here")
library("here")

# Load the data
load(file = here("Data", "Market.rda"))

# Load the function 
source(file = here("Functions", "price_call.r")) # Prices calls using the Black-Scholes formula
source(file = here("Functions", "lin_inter.r"))  # Linear interpolation of the interest rates

# Assign data to different variables
vix       <- Market$vix
sp_500    <- Market$sp500
calls     <- Market$calls
puts      <- Market$puts
rates     <- matrix(data = NA, nrow = length(Market$rf), ncol = 2)
rates[,1] <- as.numeric((attributes(rf))[[2]])
rates[,2] <- Market$rf

# Assign column names to 'rates'
colnames(rates) <- c("Maturities", "Risk-free Rates")
```

# Part III: Pricing a Portfolio of Options

The portfolio under consideration contains four options: K = 1600 and T-t = 20 days, K = 1650 and T-t = 20 days, K = 1750 and T-t = 40 days, and K = 1800 and T-t = 40 days. We assume that there is 250 days in a year and thus convert times to expiry in years by dividing by 250. We first create a matrix 'book' that contains information regarding the options in the portfolio.

```{r}
# Create matrix
book_1 <- matrix(data = NA, nrow = 4, ncol = 4)

# Assign names to columns
colnames(book_1) <- c("Quantity", "Call", "StrikePrice", "Maturity")

# Store initial values
book_1[1,] <- c(1, 1, 1600, 20 / 250)
book_1[2,] <- c(1, 1, 1650, 20 / 250)
book_1[3,] <- c(1, 1, 1750, 40 / 250)
book_1[4,] <- c(1, 1, 1800, 40 / 250)
```

The next step is to use the most recent underlying asset price and VIX value as well as the interpolated risk-free rates to compute the value of each option in the portfolio that we store in the variable 'call_price'. The value of the portfolio of options is simply the sum of each option's value.

[Add a description of the inputs of the function price_call and lin_inter.]

```{r}
# Number of observations
n_obs <- nrow(sp_500)

# Convert 250 days per year to 360 days per year
m_1 <- unique(book_1[,4])[1] * (250 / 360)
m_2 <- unique(book_1[,4])[2] * (250 / 360)

# Interpolated interest rates
r_1 <- lin_inter(m_1)
r_2 <- lin_inter(m_2)

# Latest underlying asset price (spot price)
S_1 <- sp_500[n_obs]

# Latest VIX value
vol_1 <- vix[n_obs]

# Strike prices
K <- book_1[,3]

# Maturities
M <- book_1[,4]

# Initialize a vector
call_price <- c(rep(NA, 4))

# Compute the option values and store them in 'call_price'
call_price[1] <- Price_call(S_1, K[1], r_1, vol_1, M[1])
call_price[2] <- Price_call(S_1, K[2], r_1, vol_1, M[2])
call_price[3] <- Price_call(S_1, K[3], r_2, vol_1, M[3])
call_price[4] <- Price_call(S_1, K[4], r_2, vol_1, M[4])

# Compute the price of the portfolio and store it in 'PF_price'
PF_price <- sum(call_price)
```

It is not surprising to see that the value of the first option is higher than the value of the second option. Indeed, since the strike price is lower for the first option, the first option is deeper ITM than the second option and it should therefore have a higher price. The same reasoning can be applied between the third and fourth options.

# Part IV: One Risk Driver and Gaussian Model

We now want to estimate the value-at-risk (VaR) and the expected shortfall (ES) of this portfolio of options over the course of the following week. To do so, we must first compute the underlying asset log returns.

```{r}
# Daily log returns
log_return <- diff(log(sp_500))
```

Next, we assume that the underlying asset log returns follow a normal distribution and generate 10 000 scenarios for the underlying asset price. The normal distribution parameters can be found by computing the empirical mean and standard deviation of the underlying asset daily log returns.

```{r}
# Number of log returns
n_ret <- length(log_return)

# Calibration
mu_hat <- mean(log_return)
s2_hat <- mean((log_return - mu_hat)^2) * (n_ret / (n_ret - 1))
s_hat  <- s2_hat^0.5

# Number of simulation
H <- 10000

# Number of days
t <- 5

# Portfolio  Calls - Caracteristics - 5 days later
book_2 <- book_1                                    # same as previous except days until maturity
book_2[,4] <- book_2[,4] - t / 250                  # t days later

# log return sp_500 projected in 5 days
set.seed(4321)
sim_ret <- matrix(rnorm(t*H, mean = mu_hat, sd = s_hat), nrow = H, ncol = t)

# price sp_500 projected in 5 days
S_2 <- S_1 * exp(rowSums(sim_ret))

# input for black-Schole calls pricing
r_3   <- lin_inter(m_1 - t / 360)
r_4   <- lin_inter(m_2 - t / 360)
vol_2 <- vol_1
# Strike price (K) is the same

# stocking matrix (Hx4) - H simulation, 4 calls
call_price_2 <- matrix(NA, nrow = H, ncol = 4)

# calculating and stocking call's price simulation
for (i in 1:10000){
  call_price_2[i,1] <- Price_call(S_2[i], K[1], r_3, vol_2, M[1] - t / 250)
  call_price_2[i,2] <- Price_call(S_2[i], K[2], r_3, vol_2, M[2] - t / 250)
  call_price_2[i,3] <- Price_call(S_2[i], K[3], r_4, vol_2, M[3] - t / 250)
  call_price_2[i,4] <- Price_call(S_2[i], K[4], r_4, vol_2, M[4] - t / 250)
}

# stocking H portfolio value 
PF_price_2 <- rowSums(call_price_2)

# P&N of the H simulation 
r_pl <- lin_inter(t / 360)  #actualisation factor
pl   <- PF_price_2 * exp(-(t / 360) * r_pl) - PF_price

# VaR and EVaR
alpha <- 0.95
VaR <- sort(pl)[(1 - alpha) * H]
EVaR <- mean(sort(pl)[1:((1 - alpha) * H)])

# histogram
hist(pl, nclass = round(10 * log(length(pl))), probability = TRUE)

# Add vertical line for VaR value
abline(v = quantile(pl, probs = (1 - alpha)),
       lty = 2, ## line type: 2 = dashed
       lwd = 2.5, ## line width: the largher, the thicker
       col = "red")
```

# Part V: Two risk drivers and Gaussian model

```{r}


```
