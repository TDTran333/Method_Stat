---
title: "Statistical Methods in Financial Engineering - Risk Management Project"
author: Chloe Morin-Leclerc, Felix-Antoine Groulx, Denis Genest, Thien Duy Tran
date: "`r format(Sys.time(), '%B %e, %Y')`"
output: html_notebook
---

<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
td {  /* Table  */
  font-size: 8px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

# Part I: Project Guidelines

## Context
You work as a quantitative analyst for a large investment bank. You and your team are responsible for
challenging the models used by traders and risk managers. You work with R and love reproducible research.
All your files are written in Rmarkdown or R notebook.

You can watch the introductory video on Rmarkdown to help you build properly the R file.
Moreover, you use GitHub with your team. You’ll build a dedicated project for the tasks below and use
RStudio with GitHub extensively. You also use Loom to share your findings with other teams in the investment
bank.

## Learning Objectives
1. Content (scientific rigor, concepts, creativity).\
2. Choose the right tools.\
3. Implement the steps correctly.\
4. Come up with innovative solutions.\

## Form: Coding, Collaboration and Presentation
1. Build RStudio project with proper folder structure and Rmarkdown/nootebook file to reproduce your results.\
2. Program with state-of-the-art coding standards.\
3. Use GitHub repository for collaborative research.\
4. Use Loom video for presenting your results.

## Objective
The objective of this project is to implement the risk management framework used for estimating the risk of a book of European call options by taking into account risk drivers such as the underlying asset and the implied volatility of the options.

# Part II: Data

## Loading the Data
The first step is to load the database 'Market'. 'Market' is a list of 5 elements: S&P500 index prices, VIX values, the term structure of interest rates, and traded call and put options information. To make sure this code can run on any platform, we use the library 'here'.

```{r}
# install.packages("here")
library("here")

# Load the data
load(file = here("Data", "Market.rda"))

# Load the function 
source(file = here("Functions", "price_call.r")) # Prices calls using the Black-Scholes formula
source(file = here("Functions", "lin_inter.r"))  # Linear interpolation of the interest rates

# Assign data to different variables
vix    <- Market$vix
sp_500 <- Market$sp500
rf     <- Market$rf
calls  <- Market$calls
puts   <- Market$puts
```

# Part III: Pricing a Portfolio of Options

The portfolio under consideration contains four options: K = 1600 and T-t = 20 days, K = 1650 and T-t = 20 days, K = 1750 and T-t = 40 days, and K = 1800 and T-t = 40 days. We assume that there is 250 days in a year and thus convert times to expiry in years by dividing by 250. We first create a matrix 'book' that contains information regarding the options in the portfolio.

```{r}
# Create matrix
book <- matrix(data=NA, nrow = 4, ncol = 4)

# Assign names to columns
colnames(book) <- c("Quantity","Call","StrikePrice","Maturity")

# Store initial values
book[1,] <- c(1, 1, 1600, 20 / 250)
book[2,] <- c(1, 1, 1650, 20 / 250)
book[3,] <- c(1, 1, 1750, 40 / 250)
book[4,] <- c(1, 1, 1800, 40 / 250)
```

The next step is to use the most recent underlying asset price and VIX value as well as the interpolated risk-free rates to compute the value of each option in the portfolio that we store in te variable 'call_price'. The value of the portfolio of options is simply the sum of each option's value.

```{r}
# Interpolated interest rates
r_1 <- lin_inter(book[1,4])
r_2 <- lin_inter(book[3,4])

# Latest underlying asset price (spot price)
S   <- sp_500[length(sp_500)]

# Latest VIX value
vol <- vix[length(vix)]

# Strike prices
K   <- book[,3]

# Maturities
N   <- book[,4] 

# Initialize a vector
call_price <- c(rep(NA, 4))

# Compute the option values and store them in 'call_price'
call_price[1] <- Price_call(S, K[1], r_1, vol, N[1])
call_price[2] <- Price_call(S, K[2], r_1, vol, N[2])
call_price[3] <- Price_call(S, K[3], r_2, vol, N[3])
call_price[4] <- Price_call(S, K[4], r_2, vol, N[4])

# Compute the price of the portfolio and store it in 'PF_price'
PF_price <- sum(call_price)
```

It is not surprising to see that the value of the first option is higher than the value of the second option. Indeed, since the strike price is lower for the first option, the first option is deeper ITM than the second option and it should therefore have a higher price. The same reasoning can be applied between the third and fourth options.

# Part IV: One Risk Driver and Gaussian Model

We now want to estimate the value-at-risk (VaR) and the expected shortfall (ES) of this portfolio of options over the course of the following week. To do so, we must first compute the underlying asset log returns.

```{r}
# Daily log returns
log_return <- diff(log(sp_500))
```

Next, we assume that the underlying asset log returns follow a normal distribution and generate 10 000 scenarios for the underlying asset price. The normal distribution parameters can be found by computing the empirical mean and standard deviation of the underlying asset daily log returns. [Je suis rendu là...]

```{r}
# model calibration
tmp    <- length(log_return)

mu_hat <- mean(log_return[seq(1,tmp,5)])
s2_hat <- mean((log_return[seq(1,tmp,5)] - mu_hat)^2) #n/(n-1)
s_hat  <- s2_hat^0.5

# number of simulation
H <- 10000
t <- 5 / 365

# Portfolio  Calls - Caracteristics - 5 days later
book_2 <- book                 # same as previous except days until maturity
book_2[,4] <- book_2[,4] - t   # t days later

# log return sp_500 projected in 5 days
# set seed(1234).....
sample <- rnorm(H, mean=mu_hat, sd=s_hat)

# price sp_500 projected in 5 days
S_2 <- sp_500[length(sp_500)] * exp(sample)

# input for black-Schole calls pricing
r_3   <- lin_inter(book_2[1,4])
r_4   <- lin_inter(book_2[3,4])
vol_2 <- vix[length(vix)]
K_2   <- book_2[,3]
N_2   <- book_2[,4] 

# stocking matrix (Hx4) - H simulation, 4 calls 
call_price_2 <- matrix(NA, nrow = H, ncol = 4)

# calculating and stocking call's price simulation
for (i in 1:10000){
  call_price_2[i,1] <- Price_call(S_2[i], K_2[1], r_3, vol_2, N_2[1])
  call_price_2[i,2] <- Price_call(S_2[i], K_2[2], r_3, vol_2, N_2[2])
  call_price_2[i,3] <- Price_call(S_2[i], K_2[3], r_4, vol_2, N_2[3])
  call_price_2[i,4] <- Price_call(S_2[i], K_2[4], r_4, vol_2, N_2[4])
}

# stocking H portfolio value 
PF_price_2 <- apply(call_price_2,1,sum)

# P&N of the H simulation 
r_pl <- lin_inter(t)  #actualisation factor
pl   <- PF_price_2 * exp(-t *r_pl) - PF_price

# VaR and EVaR
alpha <- 0.95
VaR <- sort(pl)[(1 - alpha) * H]
EVaR <- mean(sort(pl)[1:((1 - alpha) * H)])

# histogram
hist(pl, nclass = round(10 * log(length(pl))), probability = TRUE)

# Add vertical line for VaR value
abline(v = quantile(pl, probs = (1 - alpha)),
       lty = 2, ## line type: 2 = dashed
       lwd = 2.5, ## line width: the largher, the thicker
       col = "red")
```